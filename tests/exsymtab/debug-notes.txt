TODO
====

Write tests for extended symbol table traps discussed on May 1

break tcc_compile_string
break tcc_relocate_ex
# This is where the interesting parsing stuff happens
break block
break gfunc_call
lib_path=../..

# Probably want to break on decl0

# Try this to break within next():
break /home/dcmertens/projects/tinycc/tccpp.c:3017

# Otherwise, after the first breakpoint above gets tripped, add this:
break next_nomacro_spc

### When I call tcc_add_symbol... ###

# ... I get to relocate_syms() ...
# What is sh_num? ANS: it is SHN_ABS, which is 0xfff1.
# How does it compare to SHN_LORESERVE == 0xff00? ANS: it is greater.
# If it were lower, it would be changed, so in relocate_syms(), the address is not changed.



line 2329 of libtcc.c
int flagless_original = curr_Def->v & ~(SYM_STRUCT | SYM_FIELD | SYM_FIRST_ANOM);



#### April 27 2014

It's been a while since I last looked at this code.

# Catching up

As of right now, there are tests under tests/exsymtab/, and tests 01, and 20 pass. 30 does
not pass. Neither does the overly complex 09, which is copied and unmodified in 40. 50
does not pass either, and a printout of the address of the two functions "fib" and
"fib_of_5" show that they have the *same* address, which is wrong.

To proceed, and to lose as little ground between steps as possible, I am going to proceed
systematically. I will begin by focusing on test 20.

# Getting oriented with test 20

Test 20 defines a struct in one context, copies that context's symbol table, applies that
symbol table to another context, and tries to compile code that uses the struct
definition. The struct "constructor" can be obtained from the first context after
compilation and it runs without trouble. It is possible to ensure it works by manually
unpacking the struct (treating it like a two-element array).

The error message when the second compiler runs into trouble is 
  <string>:3: error: field not found: x
This means that the compiler does not have any trouble with the statement on the previous
line:
  struct point * pt = pt_p;
That suggests that it is able to search for the symbol called "point" in the
extended symbol table and find it. To be sure of this, I added the following lines to the
extended symbol table search found in the vicinity of line 2280 in tccpp.c:
  if (!memcmp("point", p1, len)) printf("Looking for a point with an extended symbol table callback\n");
  				ts = tcc_state->symtab_name_callback(
  					p1, len, tcc_state->symtab_callback_data, 0);
  if (!memcmp("point", p1, len) && ts) printf("Found a point symbol! Returning %d\n", ts);
These if statements print during the compilation stage before the second compilation
croaks. So we can be sure that the system finds the symbol. Furthermore, the printout of
the symbol number suggests that the return value is sensible.

At present, test 20 shows the following problem:

  ############################################################
  # Extended symbol table entries are not correctly queried. #
  ############################################################

How might we test this? I would have to locate where struct data offsets are queried and
then print out some diagnostics whenever we try to access data from the "point" struct.
Where does this occur? Thanks to ack, I found that this error is printed out on line 3954
of tccgen.c

In the vicinity of this error, the type of the struct that we are accessing is stored in
vtop. vtop is an SValue, a struct defined on line 319 of tcc.h. vtop->type is a CType,
a struct defined on line 298 of the same header file. Judging by the usage, the type's
ref slot (vtop->type.ref) is a Sym linked list. The Sym struct is defined on line 329 of
tcc.h. The v field of that struct is what we're looking for, and is the symbol token of
the Sym in question.

The while loop in tccgen.c that precedes the current error checks if any of the members
of the linked list have the same symbol token as the current symbol token, mostly. The
actual symbol token compared is the current symbol token OR'd with SYM_FIELD. Also, the
search through the linked list starts with the *second* element of the list, not the
first. Here are some important questions worth asking:

  Q: What is contained in the first element of the list?
  Q: When the elements of the list are copied in the symbol table copy function, are
     they copied with the correct flags? [ans line 97]
  Q: Is the token symbol for "x" correctly retrieved for this situation?

I can most easily answer the second question first. The symbol copying is contained in
libtcc.c in the vicinity of line 2220. In particular, all flags are split off of the token
symbol in the vicinity of line 2210, then added back after the arithmetic. Every single
symbol is copied and its symbol token updated in this one spot. The ref pointer is
copied further down, in such a way as to refer to the new, copied symbol token.

I now suspect, strongly, that the problem is that the flags are being mishandled
somewhere. Line 2503 of libtcc.c copies over the flags, which seems odd since the
tokenizer does not understand context and cannot differentiate between struct names,
field names, etc. I do not understand the role of these. At any rate, the value SYM_FILED
is OR'd with the symbol token before the comparison, so the return value of the
name-to-token function should probably *not* have that value. Either that, or all such
flags get stripped out at some point:

  Q: Do extra flags such as SYM_FIELD get stripped out from the symbol token after it is
     returned?



#### April 28 2014

New investigations to resolve the questions asked last night. It turns out that the token
for the "x" struct field is never identified in the extended symbol code. This suggests
that there may be a mistake in the code that searches through extended symbols.

To reach this observation, I added the following diagnostic to tccgen.c, line 3954:

 { printf("Could not find token %x\n", tok);
                tcc_error("field not found: %s",  get_tok_str(tok & ~SYM_FIELD, NULL));
 }


#### April 30 2014

Continuing with my previous line of inquiry, I decided to look more closely at the
preprocessor parsing of single-character tokens, such as "x". How are TokenSym structs
allocated for these? Do they get copied by the symbol table copier?

# TokenSym for x?

To answer that question, I look into the token symbol copying in libtcc. Adding this line
to the copy function:

  printf("Just copied token with string %s\n", tok_sym->str);

lets me check for all tokens that get copied. Do we see "x"?

Many, many, many tokens are created, more than I care to know. They are all probably
preprocessor macros, and I should probably find some way to avoid compiling them each
time the compiler gets invoked. At any rate, we *do* have an "x" token, along with a "y"
token.

Why is this odd? It appears that the lookup-by-name code in test_setup.h can find the
"point" and "pt" token symbols, but is unable to find the [x] token symbol.

# TokenSym search

This sugests that the lookup-by-name code is either broken or not called for "x". To
check this, I added this line to the token lookup-by-name function in test_setup.h:

  printf("Looking up token with name [%s]\n", name_to_find);

I also removed diagnostic output to make the output easier to digest. The output is what
I would have expected:

  Looking up token with name [sq_distance_to_pt]
  Looking up token with name [pt_p]
  Looking up token with name [point]
  Looking up token with name [pt]
  Looking up token with name [pt]
  Looking for an x with an extended symbol table callback
  Looking up token with name [x]
  Looking up token with name [sq_distance_to_pt???]

Thus we are indeed asked to find "x", and I am confident that the "x" tokenSym is indeed
copied to the extended symbol table. There must be an issue with the lookup procedure.

To check if the lookup procedure is faulty, I added a printout to the lookup function that
displays all token names that failed, either because the names didn't match or because the
TokenSym is "not shareable".

And there we see it, hidden among scores of similar lines:

  TokenSym with name [x] does not match or is not shareable

which suggests that the TokenSym for "x" is not shareable. This is odd since the TokenSym
for "point" is shareable, apparently. My next step, then, is to test if I can make this
field shareable.

# Shareability

There are two tests I can perform to see if I can get this to work. The first is to try
using a longer name, in case single-letter tokens behave oddly. The second is to look
more closely at the logic for sharable tokens. I will begin with the first idea. To do
this, I simply rename the fields of the struct from "x" and "y" to "xval" and "yval". For
good measure I also changed the names of the arguments to new_point().

Once again, I get this message:

  Looking up token [xval]
  Could not find token 1000046f

So it appears that the members of structs are not shareable, and so lookup_by_name fails
to return the TokenSym for this field.


#### May 1 2014

After looking at the logic for tcc_tokensym_is_shareable, I think I understand more
clearly that the TokenSym's fields that are checked in this function would point to
globally visible things. The function might be better named tcc_tokensym_has_globals.

At any rate, I decided to remove the "is_shareable" check from the lookup_by_name
function in test_setup.h to see if the struct code will properly compile.

HOLY SHIT IT WORKED!!! HURRAY!!! TEST 30 NOW PASSES!!!

And just to make sure that things aren't stupid, I decided to change one of the variable
names back to a single character, and to reuse that token repeatedly. This way single
character tokens as well as repeated use of the same extended token in different contexts
get tested.

Yes, it all works just as it should. :-D

# Potential TokenSym lookup issues

I have a worry about a potential trap in TokenSym lookup by name. This would only reveal
itself when using three contexts.

In context #1, I write a function called "foo". This is a globally accessible thing, so it
gets stored in the TokenSym's function slot. This TokenSym is copied to an extended symbol
table.

In context #2, I include the extended symbol table from context #1 and write a macro
called "foo". The token "foo" is associated with the TokenSym in the first context's
extended symbol table, so that TokenSym (and tok reference) is returned. This globally
accessible thing gets stored in the *original* TokenSym's define slot! Furthermore, when
the extended symbol table is made from context #2, it does not include a TokenSym for
this symbol! The symbol itself should be in this context's list of symbols, so it will be
copied. Potential problems include:

  1) The original TokenSym's direct pointer to the symbol itself will not be updated with
     the creation of the extended symbol table. This will be a potential memory leak.
  2) If context #2 is applied to a later context, the lookup_by_name function will have to
     know to look for tokens in context #1, or it won't find "foo" defined as a macro.
  3) If context #1 is applied to a later context, the "foo" macro slot will already be
     taken, even though the macro was *not* defined in context #1. Thus if we want to have
     two contexts (say #2 and #3) that morph the behavior of the function call with two
     different macro wrappers, we will likely run into trouble.

I need to write tests for all of these, but would like to move to other things first.


