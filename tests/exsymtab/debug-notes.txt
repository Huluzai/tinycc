TODO
====

- Write a struct declaration sharing test that uses non-int types, like float or char[10]
- Write tests for extended symbol table traps discussed on May 1
- variable interpolation: function unary() in tccgen.c
- may need to clear the .c field of each sym's type after each context's use
- check for pad entries using pad_findmy_pv or pad_findmy_pvn, then get the sv using PAD_SV

====

break tcc_compile_string
break tcc_relocate_ex
# This is where the interesting parsing stuff happens
break block
break gfunc_call
lib_path=../..

# Probably want to break on decl0

# Try this to break within next():
break /home/dcmertens/projects/tinycc/tccpp.c:3017

# Otherwise, after the first breakpoint above gets tripped, add this:
break next_nomacro_spc

### When I call tcc_add_symbol... ###

# ... I get to relocate_syms() ...
# What is sh_num? ANS: it is SHN_ABS, which is 0xfff1.
# How does it compare to SHN_LORESERVE == 0xff00? ANS: it is greater.
# If it were lower, it would be changed, so in relocate_syms(), the address is not changed.



line 2329 of libtcc.c
int flagless_original = curr_Def->v & ~(SYM_STRUCT | SYM_FIELD | SYM_FIRST_ANOM);



#### April 27 2014

It's been a while since I last looked at this code.

# Catching up

As of right now, there are tests under tests/exsymtab/, and tests 01, and 20 pass. 30 does
not pass. Neither does the overly complex 09, which is copied and unmodified in 40. 50
does not pass either, and a printout of the address of the two functions "fib" and
"fib_of_5" show that they have the *same* address, which is wrong.

To proceed, and to lose as little ground between steps as possible, I am going to proceed
systematically. I will begin by focusing on test 20.

# Getting oriented with test 20

Test 20 defines a struct in one context, copies that context's symbol table, applies that
symbol table to another context, and tries to compile code that uses the struct
definition. The struct "constructor" can be obtained from the first context after
compilation and it runs without trouble. It is possible to ensure it works by manually
unpacking the struct (treating it like a two-element array).

The error message when the second compiler runs into trouble is 
  <string>:3: error: field not found: x
This means that the compiler does not have any trouble with the statement on the previous
line:
  struct point * pt = pt_p;
That suggests that it is able to search for the symbol called "point" in the
extended symbol table and find it. To be sure of this, I added the following lines to the
extended symbol table search found in the vicinity of line 2280 in tccpp.c:
  if (!memcmp("point", p1, len)) printf("Looking for a point with an extended symbol table callback\n");
  				ts = tcc_state->symtab_name_callback(
  					p1, len, tcc_state->symtab_callback_data, 0);
  if (!memcmp("point", p1, len) && ts) printf("Found a point symbol! Returning %d\n", ts);
These if statements print during the compilation stage before the second compilation
croaks. So we can be sure that the system finds the symbol. Furthermore, the printout of
the symbol number suggests that the return value is sensible.

At present, test 20 shows the following problem:

  ############################################################
  # Extended symbol table entries are not correctly queried. #
  ############################################################

How might we test this? I would have to locate where struct data offsets are queried and
then print out some diagnostics whenever we try to access data from the "point" struct.
Where does this occur? Thanks to ack, I found that this error is printed out on line 3954
of tccgen.c

In the vicinity of this error, the type of the struct that we are accessing is stored in
vtop. vtop is an SValue, a struct defined on line 319 of tcc.h. vtop->type is a CType,
a struct defined on line 298 of the same header file. Judging by the usage, the type's
ref slot (vtop->type.ref) is a Sym linked list. The Sym struct is defined on line 329 of
tcc.h. The v field of that struct is what we're looking for, and is the symbol token of
the Sym in question.

The while loop in tccgen.c that precedes the current error checks if any of the members
of the linked list have the same symbol token as the current symbol token, mostly. The
actual symbol token compared is the current symbol token OR'd with SYM_FIELD. Also, the
search through the linked list starts with the *second* element of the list, not the
first. Here are some important questions worth asking:

  Q: What is contained in the first element of the list?
  Q: When the elements of the list are copied in the symbol table copy function, are
     they copied with the correct flags? [ans line 97]
  Q: Is the token symbol for "x" correctly retrieved for this situation?

I can most easily answer the second question first. The symbol copying is contained in
libtcc.c in the vicinity of line 2220. In particular, all flags are split off of the token
symbol in the vicinity of line 2210, then added back after the arithmetic. Every single
symbol is copied and its symbol token updated in this one spot. The ref pointer is
copied further down, in such a way as to refer to the new, copied symbol token.

I now suspect, strongly, that the problem is that the flags are being mishandled
somewhere. Line 2503 of libtcc.c copies over the flags, which seems odd since the
tokenizer does not understand context and cannot differentiate between struct names,
field names, etc. I do not understand the role of these. At any rate, the value SYM_FILED
is OR'd with the symbol token before the comparison, so the return value of the
name-to-token function should probably *not* have that value. Either that, or all such
flags get stripped out at some point:

  Q: Do extra flags such as SYM_FIELD get stripped out from the symbol token after it is
     returned?



#### April 28 2014

New investigations to resolve the questions asked last night. It turns out that the token
for the "x" struct field is never identified in the extended symbol code. This suggests
that there may be a mistake in the code that searches through extended symbols.

To reach this observation, I added the following diagnostic to tccgen.c, line 3954:

 { printf("Could not find token %x\n", tok);
                tcc_error("field not found: %s",  get_tok_str(tok & ~SYM_FIELD, NULL));
 }


#### April 30 2014

Continuing with my previous line of inquiry, I decided to look more closely at the
preprocessor parsing of single-character tokens, such as "x". How are TokenSym structs
allocated for these? Do they get copied by the symbol table copier?

# TokenSym for x?

To answer that question, I look into the token symbol copying in libtcc. Adding this line
to the copy function:

  printf("Just copied token with string %s\n", tok_sym->str);

lets me check for all tokens that get copied. Do we see "x"?

Many, many, many tokens are created, more than I care to know. They are all probably
preprocessor macros, and I should probably find some way to avoid compiling them each
time the compiler gets invoked. At any rate, we *do* have an "x" token, along with a "y"
token.

Why is this odd? It appears that the lookup-by-name code in test_setup.h can find the
"point" and "pt" token symbols, but is unable to find the [x] token symbol.

# TokenSym search

This sugests that the lookup-by-name code is either broken or not called for "x". To
check this, I added this line to the token lookup-by-name function in test_setup.h:

  printf("Looking up token with name [%s]\n", name_to_find);

I also removed diagnostic output to make the output easier to digest. The output is what
I would have expected:

  Looking up token with name [sq_distance_to_pt]
  Looking up token with name [pt_p]
  Looking up token with name [point]
  Looking up token with name [pt]
  Looking up token with name [pt]
  Looking for an x with an extended symbol table callback
  Looking up token with name [x]
  Looking up token with name [sq_distance_to_pt???]

Thus we are indeed asked to find "x", and I am confident that the "x" tokenSym is indeed
copied to the extended symbol table. There must be an issue with the lookup procedure.

To check if the lookup procedure is faulty, I added a printout to the lookup function that
displays all token names that failed, either because the names didn't match or because the
TokenSym is "not shareable".

And there we see it, hidden among scores of similar lines:

  TokenSym with name [x] does not match or is not shareable

which suggests that the TokenSym for "x" is not shareable. This is odd since the TokenSym
for "point" is shareable, apparently. My next step, then, is to test if I can make this
field shareable.

# Shareability

There are two tests I can perform to see if I can get this to work. The first is to try
using a longer name, in case single-letter tokens behave oddly. The second is to look
more closely at the logic for sharable tokens. I will begin with the first idea. To do
this, I simply rename the fields of the struct from "x" and "y" to "xval" and "yval". For
good measure I also changed the names of the arguments to new_point().

Once again, I get this message:

  Looking up token [xval]
  Could not find token 1000046f

So it appears that the members of structs are not shareable, and so lookup_by_name fails
to return the TokenSym for this field.


#### May 1 2014

After looking at the logic for tcc_tokensym_is_shareable, I think I understand more
clearly that the TokenSym's fields that are checked in this function would point to
globally visible things. The function might be better named tcc_tokensym_has_globals.

At any rate, I decided to remove the "is_shareable" check from the lookup_by_name
function in test_setup.h to see if the struct code will properly compile.

HOLY SHIT IT WORKED!!! HURRAY!!! TEST 30 NOW PASSES!!!

And just to make sure that things aren't stupid, I decided to change one of the variable
names back to a single character, and to reuse that token repeatedly. This way single
character tokens as well as repeated use of the same extended token in different contexts
get tested.

Yes, it all works just as it should. :-D

# Potential TokenSym lookup issues

I have a worry about a potential trap in TokenSym lookup by name. This would only reveal
itself when using three contexts.

In context #1, I write a function called "foo". This is a globally accessible thing, so it
gets stored in the TokenSym's function slot. This TokenSym is copied to an extended symbol
table.

In context #2, I include the extended symbol table from context #1 and write a macro
called "foo". The token "foo" is associated with the TokenSym in the first context's
extended symbol table, so that TokenSym (and tok reference) is returned. This globally
accessible thing gets stored in the *original* TokenSym's define slot! Furthermore, when
the extended symbol table is made from context #2, it does not include a TokenSym for
this symbol! The symbol itself should be in this context's list of symbols, so it will be
copied. Potential problems include:

  1) The original TokenSym's direct pointer to the symbol itself will not be updated with
     the creation of the extended symbol table. This will be a potential memory leak.
  2) If context #2 is applied to a later context, the lookup_by_name function will have to
     know to look for tokens in context #1, or it won't find "foo" defined as a macro.
  3) If context #1 is applied to a later context, the "foo" macro slot will already be
     taken, even though the macro was *not* defined in context #1. Thus if we want to have
     two contexts (say #2 and #3) that morph the behavior of the function call with two
     different macro wrappers, we will likely run into trouble.

I need to write tests for all of these, but would like to move to other things first.

# Function declarations

I now turn my attention to shared functions. The test file for this material was test 40.
I have substantially refactored it to provide cleaner tests and testing framework. I have
also renamed it to describe better what it tests.

Currently, it appears that the function declaration itself works correctly. However, as
the test file now clearly indicates, functions from other contexts do not appear to have
the correct address, something I struck upon when examining this problem back in December.
In contrast to December, I now have an automated test that can reliably report this
failure without inducing a segmentation fault.

# Vtables

A test that falls somewhere between struct declaration sharing and function sharing is
function declaration sharing. I can achieve this test most simply by preparing a context
that declares and can assemble a vtable. I can then call the assembly function in the
test code itself, and hand off the tested struct to a second context, which can simply
work with the results. Thus is born test 35.

Unfortunately, test 35 behaves very strangely. Any direct access to the function address
of the struct causes the *compiler* to segfault. To see this, instead of this (erroneous)
definition for 

  void * distance_func_ptr(struct point * pt) {
    return pt->x;
  }

try this one:

  void * distance_func_ptr(struct point * pt) {
    return pt->squared_distance;
  }

The compiler croaks. Dereferencing an integer in a struct works, but apparently not a
function pointer.

# Non-integer struct members

We now reach an interesting question: are ints just a special case? What if I used double
or float members in the struct? Would the code still compile?


#### May 4, 2014

I realized that a less complicated test for functions would be to compile a function
declaration, then share it. This avoids the actual function compilation step and any
associated headache with that. For this, I moved the current test 40 to number 45, and
created test 40-two-contexts-func-decl-share.c. In this test, we have a pre-compiled
function (written directly into the test source code). The declaration for this function
is in the first while a use of that function is in the second. This is essentially a test
of whether simple .h precompilation can work.

IT WORKS! HURRAY!

This means that if I have a C library that has already been compiled, and I then parse a
header for that file, the parsed header context can be effectively shared! Awesome! It
also suggests that if I (1) declare a set of functions in one compilation context, (2)
compile them in a second, and (3) invoke them in a third, then it should also work. Hmm...

Test 42 tests the above idea. Test 45, in contrast, simply compiles a function and then
shares the context that includes the function compilation. In test 42, I have three three
contexts, not just two.

IT WORKS AGAIN! HURRAY!

So this means that I am actually very close to having everything working. We see that if a
block of code is filled with declarations, such as struct declarations and the like, then
I can share it. The problem arises when I have definitions. I suspect that this is just as
much a problem when sharing global variables, since in some sense a compiled function is a
global thing.

In particular, if I really want to have a set of functions or globals available, I can
add (context-specific) global variables and function *pointers*, write an initialization
function for the compiled context that sets those the the appropriate values, and finally
call that initialization function just after the code block has run.

This approach, however, seems rather hackish to me. I would rather simply get the
definitions to work out-of-the-box.

I strongly suspect that this has to do with the nature of the symbol. That is, I suspect
that the originally compiled symbol has a flag indicating that it is a strongly linked
value, which is appropriate for the newly compiled code block. However, when it is used in
any later block, the symbol must be marked as weakly linked. This is my hunch...

To test this hunch, I will try weakening all symbols that get *copied* to the extended
symbol table, by ORing VT_WEAK to the symbol's type.t field (roughly line 2250 in
libtcc.c). With this change, I then need to see if all of the previously passing tests
still pass, and if test 45 suddenly passes, too.

Unfortunately, this change broke test 30 and 35, and did not make test 45 pass. There must
be something else going on.

What if I go the other route, and ensure that the offset (i.e. the symbol's c field) is
zero? This is, ostensibly, the offset of the symbol in the elf symbol table. If the offset
is zero, it should indicate that the symbol has not yet been allocated. Line 460 of
libtcc.c seems to suggest this could work. To find out if this'll work, I will change the
assignment of the .c field in the symbol table copy code so that it is zero. Looking over
how the .c field is used, this seems like it must be far to blunt a tool. However, I will
try it and see if it makes things work...

It sorta works! Not entirely, but somewhat. The weak linkage breaks things, but the
combination makes test 45 pass. Now we have the simple question: is weak linkage
necessary? To answer this question, I simply remove the ORed part of the symbol copy that
I inserted earlier.

Hurray! Now the 40-series tests pass. Unfortunately, the 30-series tests fail, which means
that I need to only set the c field very selectively. Reading through tccgen.c, it looks
as though the c field can contain things such as pointer offsets (for struct members) and
string lengths, among other things. So, I should only set it to zero for very specific
symbols, and otherwise I should copy it.

For a first test, I will see if checking the symbol's type.t field is sufficient. It seems
plausible that this will have the right information.

HURRAY! IT WORKS NOW!

Well, mostly. I just realized that test 35 was hobbled so that it always failed, but at
least it always completed without segfaulting. Now, if I unhobble test 35, it segfaults
for reasons I do not yet understand. This means that vtable declarations do not yet work
correctly. However, all of the other functionality, including function declaration
sharing, now works! Awesome!

More work lies ahead, but these are major milestones! :-D

#### May 16, 2014

I have spent quite a bit of time working on the Perl bindings to this library. I kept
encountering trouble, but they gave me enough insight to dig back into the libtcc side of
things. I finally figured out that anonymous symbols are not copied to the symbol table,
and that they had to be copied on their own. I figured out the intricacies of what
information is used in which context, and only copying the right stuff at the right time.
Now, I am pretty sure that function signatures, even complex ones, are copied correctly.

As such, now the un-hobbled test 35 passes! HURRAY!!!!

My bindings for libperl still do not work, but I think I have made significant strides on
getting the tcc symbol table copying up and running.

#### Fall, 2014

Been a little while. Let's see if I can figure out where I left off.

I remember that some segfaults in C::Blocks inspired a set of tests, specifically those in
test 28. My other recent commits before putting the project aside include test 51 and 70.
(Test 29 is identical to 28; I'm not quite sure what I had intended to do with that.)

Test 28 segfaults. It creates a context in which it #defines macros. It creates a second
context that consumes the first by creating new macros that depend upon those defined in
the first. Finally, it creates a third context that uses the macros defined in the second
context. (This is analogous to a C::Blocks-based library that creates some macros which
themselves use the Perl C API, implemented using macros.) The segfault occurs during the
compilation of the third context.

Test 51 passes. It defines a function in one context and uses it in later contexts
without declaring it. This may just be tcc defaulting to integer inputs and outputs for
unknown functions, or it may indicate that the function declaration is being properly
shared.

Test 70 fails three of its 67 tests. The three failing tests all occur with the c field
of the function Sym, which is expected to be zero, but is set to 3 after being used in a
dependent context. I seem to recall that the value of c means that the definition is
given externally, which means that the compiler doesn't look up the definition's function
pointer address. I'd prefer if the compiler looked it up; otherwise it's one more thing
that the compilation manager has to wrestle with.

So I paused work on this project with two open questions: (1) Why does deep macro use
lead to segfaults? (2) Why does a consuming context modify the c field of a function Sym?

#### September 4, 2014

To help answer these questions, I created a new make file extension, .gdb. Now when I try
to make a test and set the extension to .gdb, it'll compile and run the executable under
gdb.

Doing so revealed the following problem with test 28:

  Program received signal EXC_BAD_ACCESS, Could not access memory.
  Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000000
  pstrcpy (buf=0x7fff5fbfe62f " ", buf_size=1025, s=0x0) at libtcc.c:144
  144	            c = *s++;

#### September 5, 2014

Hmmm, that's a string copy starting from a null address. Here's the stack trace:

#0  pstrcpy (buf=0x7fff5fbfe62f " ", buf_size=1025, s=0x0) at libtcc.c:144
#1  0x0000000100008af7 in TOK_GET [inlined] () at /Users/dcmertens/projects/Perl/tinycc/tccpp.c:1015
#2  0x0000000100008af7 in macro_is_equal [inlined] () at /Users/dcmertens/projects/Perl/tinycc/tccpp.c:1016
#3  0x0000000100008af7 in define_push (v=1606411823, macro_type=1606412896, str=0x7fff5fbfea60, first_arg=0x7fff5fbfea60) at tccpp.c:1029
#4  0x000000010000ac6a in parse_define () at tccpp.c:1294
#5  0x0000000100009b90 in is_space [inlined] () at /Users/dcmertens/projects/Perl/tinycc/tcc.h:1412
#6  0x0000000100009b90 in preprocess (is_bof=1606415152) at tccpp.c:2580
#7  0x000000010000b338 in next_nomacro1 () at tccpp.c:2216
#8  0x0000000100008ed5 in next_nomacro [inlined] () at /Users/dcmertens/projects/Perl/tinycc/tccpp.c:2579
#9  0x0000000100008ed5 in next () at tccpp.c:3016
#10 0x00000001000035ca in tcc_compile (s1=0x100802c00) at libtcc.c:794
#11 0x0000000100003be3 in tcc_compile_string (s=0x100802c00, str=0x100039458 "#define add_foo_and_var_to(val) (foo + add_var_to(val))\n") at libtcc.c:849
#12 0x0000000100001197 in main (argc=2, argv=0x7fff5fbff992) at 28-three-contexts-intertwined-preprocessor-macro.c:98

I'm 99% certain that the copy from the null address is due to now knowing where to find
add_var_to().

#### September 6, 2014

The segmentation fault was due to an array dereference, in which the referent was the
null pointer. Looking back up the process, I figured the null pointer probably came from
get_tok_str. New warnings, just added, confirm this hunch.

The offset, 0x7ffffb96, looks like a large constant minus a special number. In fact,
0x80000000 - 0x7ffffb96 is 1130 (base-ten), which I believe is the value of tok_start
that is passed to copy_extended_symtab!! That means there's an errant subtraction in the
symtab copy routine.

It looks like there are two errant lines in the copy routine. I have adjusted for them,
leading to a compile time error:

  Re-defining an extended macro definition is not allowed; #undef first

I wrote that one. :-)

The problem now seems to be with define_push. I am not entirely sure what is leading to
the redefinition... it should just use the already present preprocessor token.

Looking closer, I realize that I should only issue this error when the new macro
definition is different from the original... and in the case of test 28, it is THE SAME.
Thus, if it is the same, and it is an extended preprocessor, I can just return from that
push! Perfect!

Now Test 28 runs all the way through the third! Hurray!

...

No, I was wrong. There was a typo in the test suite, fixed now. And as a result, the third
test of the suite does *not* complete. Instead, I get the compile time warnings and error

  ok 1 - First code string compiled and relocated fine
  <string>:2: warning: exsymtab copy found extended token but no preprocessor symbol for "val" (50000001)
  ok 2 - Second code string compiled and relocated fine
  <string>:4: error: macro 'add_foo_and_var_to' used with too many args

That warning has been around for quite a long time, but it didn't really lead to trouble
in a sensible way until now, finally. The macro function is defined with one argument, and
it gets called with one argument. Clearly, something is going on with the "val" token,
and it's leading to this error, somehow.

The warning is issued by get_new_deftab_pointer, in libtcc.c, indicating that we are
trying to copy an extended table for preprocessor defines, yet the TokenSym struct for the
given token has no Sym object in the sym_define slot.

However, it seems quite plausible that this should not give a warning if the symbol is
a macro argument. parse_define(), in tccpp.c, indicates that macro arguments are marked
with SYM_FIELD. That bit is set with the "val" token index in the warning above. It may
make sense to suppress that warning if the symbol is a SYM_FIELD.

Having fixed that, I still have the error of too many args. I turn my attention to
parse_define, defined in tccpp.c. During argument processing, sym_push2 gets the new
symbol pointer. If sym_push2 returns a null pointer for extended preprocessor symbols,
then the argument list will expect zero arguments. Is this the case?

The function sym_push2 is defined in tccgen.c. It always pushes the symbol onto the
given symbol stack (which, in this particular case, is the define symbol stack)...

#### September 7, 2014

Aha! Preprocessor macro definitions need to do this because each of the macro arguments
needs to be able to link to the next macro argument. Thus, each argument needs its own
Symbol entry, apart from any TokenSym. The problem, however, is that my
get_new_deftab_pointer in libtcc.c assumes that it can lookup any symbol by finding its
TokenSym container, and checking the TokenSym's sym_define field. This clearly won't work
correctly for macro names used by multiple extended symbol tables, which is the case being
triggered by test 28.

To solve this properly, I think I need to be able to lookup a define stack sym by its
original address. This I can do by having a two-stage copy process: the first stage copies
most of the information, including the token stream, as well as the original Sym's address
into the (presently unused) .prev field of the new Sym struct. The second stage sets the
.next field, calling a reworked get_new_deftab_pointer, which identifies the new Sym by
matching against the addresses in the .prev field.

#### September 8, 2014

It turns out that the solution was even simpler than this: I simply needed to disable a
TokenSym check that had been in place. That was my attempt to solve a problem that can
never happen, and causing a bug in the process. Having removed that, test 28 now, finally,
passes! HURRAY!

For better or worse, however, a warning that I promoted to an error is now causing a
number of tests in the suite to fail. These include:

test 20: Cannot use name 'l' as a global variable, it is already in the extended symbol table.
test 30: Cannot use name 'pt' as a global variable, it is already in the extended symbol table.
test 35: Cannot use name 'pt' as a global variable, it is already in the extended symbol table.

And then, of course, test 70 still exhibits three failed tests, as already documented.

What is going on for these newly failing tests? For test 20, the token 'l' is not a global
variable at all but simply the name of a function argument. The same is true for 'pt' in
tests 30 and 35. Furthermore, in tests 30 and 35, 'pt' is the name of a local variable.
Even if I sort out the function argument issue, this ultimately means that the use of a
*local* variable name in an extended symbol table precludes the use of global variable by
the same name.

As such, I am beginning to believe that extended symbol tables need to be able to restore
their TokenSyms to pristine states after being used by a dependent compilation unit. This
leads, further, to the ability for a dependent extended symbol table to re-initialize the
modified TokenSyms, so that compilation units further down the chain get the full, proper
behavior. (Ultimately, this may lead to a sort of diamond inheritance problem, but I
dearly hope it is not an issue in actual practice.)

And we have a currently unused slot in the copied TokenSyms: the .hash_next field.

---

It would be nice if I could simply construct a linear MRO. Then I could order the extended
symbol tables and look up extended symbols. In that case, adding a function using the same
token as a previously defined (say) preprocessor macro argument would simply copy the old
extended TokenSym into the new extended symbol table. Because it would be asked before
the parent extended symbol table, it would be able to supply the modified answer. A simple
copy-on-write handling for extended TokenSyms would make it fairly easy implement. The
problem is that I don't know how to write a C3 linearization.

The alternative is to have each dependent extended symbol table keep track of its
modifications. When you load an extended symbol table, and then another one, the dependent
symbol table would insert temporary modifications into the original before compilation
begins. After compilation, it would then clean up any changes. This is complicated.

So, I think that C3 might be the best option, really.

---

Let's take a stop back. Why is this even a discussion? A global function can only be
declared once, of course, but argument names (apparently) go on the global stack, maybe,
and preprocessor macros can be #defined and #undef'd repeatedly. If a user pulls in
multiple extended symbol tables that redefine a preprocessor macro, then I need some way
of picking which one. This is a classic dependency calculation, and C3 is a classic
solution to this problem.


November 6, 2014
================

After a long hiatus, I was thinking again about this project. I stopped on a
snag with the symbol table. I cannot simply loan a parent symbol table to a
consuming compilation unit because that compilation unit could modify the
original symbol table. The guts underlying tcc assumes that there is only one
symbol table, and it therefore directly modifies the data structures.

The idea that occurred to me today is that perhaps I could copy the symbols at
the beginning of the compilation unit. The system would emulate the @EXPORT
model of sharing stuff... It takes only a moment's thought to remember that the
whole advantage of symbol table sharing in the first place is to avoid copying
enormous tables (i.e. Perl's C API) to every single compilation unit... damn.

But, I had another idea this evening: whenever an extended TokenSym is looked up
by name, the TokenSym struct and all of its elements should be copied to a local
TokenSym. This would happen somewhere in the vicinity of the call to
symtab_name_callback in tccpp.c. This way, you only pay for the tokensyms that
you use. This would have the unfortunate side effect that regularly used tokens
that happen to exist in the Perl C API would get copied a lot, but I'm pretty
sure it'll solve the problem and let me progress, and sub-optimal progress is
better than none at all.

In that case, I would no longer need to use the extended token flag in the tok
identifier in the way that I currently do (i.e. to sequentially list all symbols
ever seen by tcc throughout the entire process). The primary advantage of that
old system was that I had separate callbacks for retrieving identifiers, which
was a signal that pointers to those identifiers needed to be added to the
compilation unit. How do I keep that functionality?

One idea is to use the flag to mean "This is a copied extended token." Usually,
this flag will be stripped off, but in tccgen.c:sym_find, it would be a
notification that the symbol needs to be added to the compilaton unit. A
callback would be fired. Then, the TokenSym's tok field would be modified to
remove the extended symbol flag. Future calls to sym_find would check for the
extended symbol flag in the TokenSym's tok, and would not fire the callback if
the extended symbol flag were not present.

November 17, 2014
=================

Progress slow but steady. At this point, I have cleaned out the code that checks
for extended symbols in symbol lookups. The only remaining bit is to ensure that
new tokensym lookups into extended symbol tables end up creating and copying
new tokensyms. The heart of what needs to happen is simple enough. During the
token lookup in tccpp.c's next_nomacro1, we check if a given bareword exists in
an extended symbol table. If it does, then a new token in the current compiling
context is created which is a clone of the one in the extended symbol table.
This involves a copy of the define Sym, the struct Sym, and the identifier Sym,
along with all of their dependents.

Dependents? Yes, preprocessor definitions include token streams, i.e. streams of
integers that give the series of tokens for the preprocessor macro expansion.
Each one of these tokens needs to be copied to the new compiler context, and the
token stream needs to be updated from the old to the new token numbers. The
types of struct members and the arguments of functions can be structs, function
pointers, or some sort of typedef; these members and arguments also need to be
copied to the new compiler context and their token numbers updated.

In order to avoid unnecessary copying, it is important to check if a tokensym
has already been created for the dependent token. To do this, I need to check
the currently compiling context if it has a token by the same name, which is the
purpose of tok_alloc. In fact, if such a token does not yet exist, this function
will also allocate it for me, which will let me continue with a recursive copy
procedure. That's almost perfect, except that if it *does* exist, I don't want
to recursively copy, and there's no way for me to know if the returned TokenSym
needs to be copied or not. So I guess I'll have to perform the hash lookup
manually.

November 22, 2014
=================

After a lot of work, I believe I have my first shot at a re-implementation. The
final solution involves a lot of local and extended symbol table lookups, and I
am beginning to wonder if there could be a way to avoid repeated hashing of the
same character string during the extended symbol lookup. For now, I will not
worry about it, but I will make a mental bookmark that this is a potential
optimization during the copy procedure.

I actually completed this work yesterday. I have not even tried to compile it
(let alone test it), so today I will commit this work, perform a wash-rinse-
repeat until I've cleared out all of the C language typos, and then retool the
lookup code in the test suite to see if the logic (and my understanding of what
the compiler needs) is right.

November 23, 2014
=================

Having cleaned up the typos, tcc compiles again. Furthermore, as best I can
tell, it passes its usual (non-extended-symtab) test suite. Cool.

Now I need to see how it behaves with the extended symbol table test suite,
which means it's time to revise that test suite to use the new API. Even before
doing that, tests 01 and 10 passed. However, in order to get test 20 to pass, I
had to revise the contents of test_setup.h.

And now, test 20 fails after the eighth test stating:
  <string>:1: error: Internal error in extended symtab copy: token in define stream was less than tok_start
or, with a minor revision to the way that error gets reported:
  <string>:1: error: Internal error in extended symtab copy: token in define stream (28) was less than tok_start

This suggests thar there is a problem with the stream copy procedure. How could
this arise? To shed some light, I added another piece to the diagnostic, giving
  <string>:1: error: Internal error in extended symtab copy: token in define stream (28) was less than tok_start (40000000)

that means tok_start IS the first extended tokensym value, which it should not
be! This led me to an erroneous setting of the tok field for TokenSyms in
copy_extended_symtab, now fixed. That gives me a new error:
  <string>:1: error: Internal error in extended symtab copy: token in define stream (28) was less than tok_start (46F)

Now that tok_start looks right, what can I say about the token in the stream? It
seems much too small. It's the 40th token symbol. This problem arises with the
preprocessor definition:
  #define MAX(first, second) (first < second ? second : first)

My hunch is that such tokens *are* allowed, that they are just the low-value
tokens. In fact, the ASCII value 40 is the character '('!!! So it looks like it
is simply trying to copy this ASCII value. This means that token values less
than tok_start should be copied as-is, and only values larger than or equal to
tok_start should be modified.

Having fixed that, I now get a segfault after test 8 passes. Perhaps this is an
issue with the extended symbol data not being initialized?

No, unfortunately. Even with the correct initialization, the system still
segfaults. Further digging is required, more than I can spare at the moment.

November 24, 2014
=================

Making test 20 with the .dbg extension (what a wonderful tool), I see that I get
a segfault at tccpp.c:2296. Printing out the contents of local_ts, I get
  {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0,
    sym_identifier = 0x0, tok = 1073742963, len = 5, str = "f"}

It becomes quite clear that the local_ts is fine, but the access to
local_ts->sym_define->type.t is clearly erroneous. After all, this should be
*setting* the local tokensym's sym_define's type.t, not accessing it. This
should be curr_from_arg->type.t.

AND THAT FIXES TEST 20!!!! HURRAY!

And with fixes to SETUP_SECOND_CALLBACK_DATA, test 25 passes, too. :-)

Test 28 has its own by-name and by-number lookups that must be revised. Having
revised those, I get core dumps at line 2272 of tccpp.c. A quick debugging
session reveals that at least one problem lies with the value from the from
stream at len: it still has the extended symbol flag.

I still hit trouble, but the problem now appears to be in test_setup.h. A stack
trace at the new segfault indicates that there is call to sym_used, which itself
calls tcc_get_symbol with a compiler state (already compiled) of NULL! This
means that the wrapping code in the test suite is failing somehow. Of course! I
never set up the state pointers in the callback struct! And just like that, test
28 passes!

Applying identical fixups to test 29 fixes that test suite as well.

Test 30 hits a new bug:
  <string>:2: error: field not found: x

This means that the struct definition for the point struct was incorrectly
copied to the second compiler context. Following in the footsteps of
investigations from late April (found around line 120 of this document), I
placed this print statement at the end of copy_extended_tokensym:
  printf("Just copied token with string %s\n", from->str);

I see a message that clearly indicates that the token string 'x' was copied.
The next logical step would be whether the field is correctly added to the
struct Sym's list of fields, which is performed by the copy_extended_sym
function just below. I added a couple of print statements to the anonymous
and non-anonymous "next" copy blocks in that block, i.e. 
  printf("** next points to anonymous symbol with token id %X\n", next->v);
and
  printf("** next points to token id %X, named %s\n", next->v, orig_ts->str);
in the "if (next->v | SYM_FIRST_ANOM)" and "else" blocks, respectively. The very
surprising result is that I get the first printf, but next->v does not look
right! That is, I get
  ** next points to anonymous symbol with token id 10000472
The problem here is that SYM_FIRST_ANOM is defined in tcc.h as 0x08000000, which
explicitly does NOT show up in this list of bits! How then does it get through
the if block and into this chunk of code? Argh! Another print statement made it
obvious. This code:
  printf("** masked, that comes to %X\n", next->v | SYM_FIRST_ANOM);
led to this output:
  ** masked, that comes to 18000472
And it becomes quite obvious I want a bitwise AND, not bitwise OR!

With that fix, I get to a coredump, without any prints. Trying to add a flush
leads to no print, and I quickly realize that the array lookup for orig_ts fails
to mask out flags. That is easily fixed, leading me back to my original
field-not-found problem.

The next step will be to examine how struct fields are set up and stored, and to
set a dbg breakpoint on tccpp.c:2354 to step through how my fields are copied.

Line 3944 of tccgen.c suggests that the token ids of struct elements---the v
field of the Sym in the linked list of next fields---includes the SYM_FIELD
flag. This seems to be true based on tccgen.c:2984:
  ss = sym_push(v | SYM_FIELD, &type1, 0, offset);

This observation has led me to attempt a nontrivial addition to
copy_extended_sym, but it has yet to bear fruit.

November 25, 2014
=================

As I prepared for bed last night, I realized why all of the modifications I made
(late) last night were not doing any good. Nearly all of those changes focused
on CType of Syms that are in the next field of another Sym. However, the test
that I'm working with (#30) involves a struct of basic types (ints) and don't
exercise the code paths that I was modifying. That's why most of hte changes I
made last night gave no change in behavior.

What differentiates the behavior of tccpp.c line 2399 and tccgen.c line 2984?
Well, obviously, the last two arguments to sym_push in the tccgen.c code are 0
and offset. These should be the values found in from_next->r and from_next->c.
Is this the case? To find out, I added a printf and I have (along with a couple
of other nice pieces):
  Copying from old tok 10000472 (x) to new tok 50000471
  from_next->r is 0 and from_next->c is 0
  Copying from old tok 10000473 (yval) to new tok 50000472
  from_next->r is 0 and from_next->c is 4

These are the correct values for these two arguments, and the new token id has
the field bit correctly set (SYM_FIELD = 0x10000000). I must look elsewhere. One
option is to examine the final sym returned by the function. To check this, I
added a little loop just before returning that checks the contents of the next
list, getting this:
  0th element in next list has token 10000471
  1th element in next list has token 10000472

So these tokens are correctly applied as part of the symbol, s, that represents
the struct.

That brings us back to our original error: "field not found". I placed a printf
in tccgen.c during the search to see how the search is actually executed. The
problem is quite clear now: the token id for "x" includes the extended symbol
flag, which was not included in the token id in the sym in the next field. This
means I need to mask off the extended token bit before the search.

AND NOW TEST 30 PASSES! HURRAY!

Time to clean up those printfs.

Alright, now on to test 35. Without any additional modifications, test 35
segfaults after test 4. GDB reports a segfault on line 2093 of tccpp.c, and a
backtrace reveals infinite recursion (and therefore stack overflow). Apparently
copy_ctype itself calls copy_extended_sym, which calls copy_ctype, etc. This all
arises from the copy of a function pointer, which is an element of a struct.
Here are my notes from a debugging session:

  1. From the backtrace, we see that copy_extended_sym gets called by 
     copy_extended_tokensym, almost assuredly to copy the point struct's layout.
  2. The entry point in our infinite recursion is the copy of the function
     pointer's ctype (as confirmed by looking at the from_next->c field in the
     calling frame).
  3. The function pointer's CType has a basic type of pointer, unsurprisingly,
     so we start the ref copy logic in copy_ctype...

Aha! The if condition for anonymous type.ref was
  from->type.ref->v | SYM_FIRST_ANOM

which obviously should be
  from->type.ref->v & SYM_FIRST_ANOM

and that fixes the stack overflow. Unfortunately, I get a different segfault,
this time at this data access later in the same function:
  symtab[from->type.ref->v - tok_start];

This segfault is due to the fact that from->type.ref->v has the value of
0x10000000. This is exactly equal to the SYM_FIELD flag, leaving me with little
to go on except that somewhere a Sym is created with *just* the SYM_FIELD token
as flag. This I can easily work with, by simply adding a check for 
  from->type.ref->v == SYM_FIELD

in which case I use code nearly identical to the anonymous symbol copy. But, I
want to be sure that this is the right behavior before doing that. The debugger
reveals that this problem crops up during the copy of the first Sym in the next
linked list. Does this sort of thing happen regularly with function pointers?

The answer is provided in mk_pointer, as well as the behavior of post_type in
the vicinity of line 3315 and 3363. In all of these, a bare SYM_FIELD indicates
a kind of anonymous symbol, which can be copied with the exact same token id.

That squashed *that* segfault, leaving me with yet another.

The segfault arises on this line:
  TokenSym* orig_ts = symtab[from->type.ref->v - tok_start];
This gives trouble because from->type.ref->v has the value
  0x20000471
which clearly needs to be masked off. And now test 35 passes!


November 26, 2014
=================

Test 42 fails with 
  <string>:5: error: 'fib' undeclared

That's line 5 of the second code string, which is part of get_fib_address.


line 3892

Decmeber 1, 2014
================

Strange, strage behavior. Here is a gdb session that shows why things are weird:

$ make curr-dbg
(gdb) break 42-three-contexts-func-share.c:61
Breakpoint 1 at 0x402244: file 42-three-contexts-func-share.c, line 61.
(gdb) run
Starting program: /home/dcmertens/projects/Perl/tinycc/tests/exsymtab/42-three-contexts-func-share.dbg lib_path=../..
ok 1 - Code string with definition of fib function compiled and relocated fine
ok 2 - Found fib
ok 3 - Calling fib from first compiler context works
ok 4 - First code string compiled and relocated fine
ok 5 - foo

Breakpoint 1, main (argc=2, argv=0x7fffffffdd48) at 42-three-contexts-func-share.c:61
61		setup_and_compile_second_state(s2, second_code);

=====================
At this point we know that def_code and first_code copied without a hiccup.
We are about to "setup_and_compile_second_state", which is written in
test_setup.h. Before getting to that, we will add a breakpoint to tccpp.c in
copy_extended_tokensym. This function is responsible for copying the TokenSym
in the first state to a TokenSym in the second state.
=====================

(gdb) break tccpp.c:2203
Breakpoint 2 at 0x40b81a: file tccpp.c, line 2203.
(gdb) c
Continuing.

Breakpoint 2, copy_extended_tokensym (symtab=0x663af8, from=0x663d60, to=0x65bcc0) at tccpp.c:2203
2203		to->sym_identifier = copy_extended_sym(symtab, from->sym_identifier, to->tok);

=====================
Now within the tokensym copy, let's get an idea of what we're about to copy, and
where we're about to copy it.
=====================

(gdb) p/x to->tok
$1 = 0x40000470
(gdb) p (char *)(from->str)
$2 = 0x663d90 "fib"
(gdb) p/x from->tok
$3 = 0x46f
(gdb) p *from
$4 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x663b10, tok = 1135, len = 3, str = "f"}
(gdb) p *(from->sym_identifier)
$5 = {v = 1135, asm_label = 0x0, r = 560, {c = 0, d = 0x0}, type = {t = 134, ref = 0x663b58}, {next = 0x0, jnext = 0}, prev = 0x0, 
  prev_tok = 0x0}
(gdb) p/x *(from->sym_identifier)
$6 = {v = 0x46f, asm_label = 0x0, r = 0x230, {c = 0x0, d = 0x0}, type = {t = 0x86, ref = 0x663b58}, {next = 0x0, jnext = 0x0}, prev = 0x0, 
  prev_tok = 0x0}
(gdb) p/x *(from->sym_identifier.type.ref)
$7 = {v = 0x10000000, asm_label = 0x0, r = 0x10800, {c = 0x1, d = 0x1}, type = {t = 0x0, ref = 0x0}, {next = 0x663ba0, jnext = 0x663ba0}, 
  prev = 0x0, prev_tok = 0x0}
(gdb) p/x *(from->sym_identifier.type.ref->next)
$8 = {v = 0x10000470, asm_label = 0x0, r = 0x0, {c = 0x0, d = 0x0}, type = {t = 0x0, ref = 0xe00000469}, {next = 0x0, jnext = 0x0}, 
  prev = 0x0, prev_tok = 0x0}

=====================
We are copying the token for "fib" from token id 0x46f to token id 0x470. A
quick examination of the code in test 42 indicates that the first code block has
a function declaration "int fib (int n)". This is in agreement with the data
structure we see for from:
  from is a TokenSym for token "fib"
   ->sym_identifier has basic type of 0x6, a function
    ->type.ref is an anonymous symbol with type int
     ->next is a symbol with type int
Let's see if copy_extended_sym properly copies all of this information.
=====================

(gdb) s
copy_extended_sym (symtab=0x663af8, from=0x663b10, to_tok=1073742960) at tccpp.c:2348
2348	Sym * copy_extended_sym (TokenSym ** symtab, Sym * from, int to_tok) {
(gdb) s 4
copy_ctype (to_type=0x7fffffffd460, from=0x663b10, symtab=0x663af8) at tccpp.c:2313
2313		int btype = from->type.t & VT_BTYPE;
(gdb) s
2314		to_type->t = from->type.t;
(gdb) 
2315		if (btype == VT_PTR || btype == VT_STRUCT || btype == VT_FUNC) {
(gdb) p/x to_type->t
$9 = 0x86
(gdb) p/x btype
$10 = 0x6

=====================
At this point we are about to copy the function's ctype. The basic type is 0x6,
i.e. VT_FUNC, so we will perform the deep copy. The type.ref field of the from
TokenSym is SYM_FIELD, so we expect to enter the middle branch of the deep copy.
=====================

(gdb) s
2317			if (from->type.ref->v & SYM_FIRST_ANOM) {
(gdb) s
2322			else if (from->type.ref->v == SYM_FIELD) {
(gdb) s
2324				to_type->ref = copy_extended_sym(symtab, from->type.ref, SYM_FIELD);
(gdb) s
copy_extended_sym (symtab=0x663af8, from=0x663b58, to_tok=268435456) at tccpp.c:2348

=====================
We are now in copy_extended_sym to copy the type->ref. The type copy should be
trivial since the function returns a basic data type, an int.
=====================

(gdb) s
2349		if (from == NULL) return NULL;
(gdb) s
2352		to_tok |= from->v & (SYM_STRUCT | SYM_FIELD | SYM_FIRST_ANOM);
(gdb) 
2354		copy_ctype(&to_type, from, symtab);
(gdb) 
copy_ctype (to_type=0x7fffffffd390, from=0x663b58, symtab=0x663af8) at tccpp.c:2313
2313		int btype = from->type.t & VT_BTYPE;
(gdb) 
2314		to_type->t = from->type.t;
(gdb) p/x btype
$11 = 0x0
(gdb) s
2315		if (btype == VT_PTR || btype == VT_STRUCT || btype == VT_FUNC) {
(gdb) 
2336	}
(gdb) 
copy_extended_sym (symtab=0x663af8, from=0x663b58, to_tok=268435456) at tccpp.c:2355
2355		Sym * s = sym_push(to_tok, &to_type, from->r, from->c);

=====================
The next step of copy_extended_sym is to create a symbol on the symbol stack
where we can copy this function declaration data.
=====================

(gdb) p/x to_tok
$12 = 0x10000000
(gdb) p/x to_type
$13 = {t = 0x0, ref = 0x7fffffffd3d0}
(gdb) p/x from->r
$14 = 0x10800
(gdb) p/x from->c
$15 = 0x1
(gdb) n
2358		if (from->asm_label != NULL) {
(gdb) n
2365		if (from->next == NULL) return s;

=====================
The assembler label is null but the next field is not: it is the first argument:
=====================

(gdb) p from->next
$16 = (struct Sym *) 0x663ba0
(gdb) p *(from->next)
$17 = {v = 268436592, asm_label = 0x0, r = 0, {c = 0, d = 0x0}, type = {t = 0, ref = 0xe00000469}, {next = 0x0, jnext = 0}, prev = 0x0, 
  prev_tok = 0x0}

=====================
Note at this point that I don't care about the name of the token if we are
talking about a function argument. I could probably simply create a new
anonymous symbol for it. However, we do care about the token for structs, so I
cannot simply revise this code to create anonymous symbols for all "next"
fields.
=====================

(gdb) n
2369		Sym * from_next = from->next;
(gdb) n
2370		Sym **psnext = &s->next;
(gdb) n
2371		while (from_next) {
(gdb) n
2372			if (from_next->v & SYM_FIRST_ANOM) {
(gdb) n
2380			else if (from_next->v == SYM_FIELD) {
(gdb) n
2391			int new_tok = get_local_tok_for_extended_tok(from_next->v, symtab);
(gdb) n

Breakpoint 2, copy_extended_tokensym (symtab=0x663af8, from=0x663db0, to=0x65bdf0) at tccpp.c:2203
2203		to->sym_identifier = copy_extended_sym(symtab, from->sym_identifier, to->tok);
(gdb) break 2392
Breakpoint 3 at 0x40be8a: file tccpp.c, line 2392.
(gdb) c
Continuing.

Breakpoint 3, copy_extended_sym (symtab=0x663af8, from=0x663b58, to_tok=268435456) at tccpp.c:2393
2393			copy_ctype(&new_next_type, from_next, symtab);

=====================
At this point I have begun the copy procedure for the first argument in the
function. It has a named token ('n'), which needs to be looked up and copied.
The copy procedure tripped the breakpoint in copy_extended_tokensym, but I
simply moved on by setting a breakpoint where I just was (line 2391) and
continuing.
=====================

(gdb) p/x new_tok
$19 = 0x50000471
(gdb) n
2394			*psnext = sym_push(new_tok, &new_next_type, from_next->r, from_next->c);
(gdb) p/x new_next_type
$20 = {t = 0x0, ref = 0x65b360}
(gdb) n
2397			from_next = from_next->next;
(gdb) n
2398			psnext = &((*psnext)->next);
(gdb) p from_next
$21 = (Sym *) 0x0
(gdb) n
2371		while (from_next) {

=====================
The new token has a different number from the old one, and also has the extended
sym flag. The new type is correct (.t = 0, so ignore ref) and from_next is null,
so we will be done when we evaluate this while check.
=====================

(gdb) n
2401		return s;
(gdb) p/x *s
$22 = {v = 0x10000000, asm_label = 0x0, r = 0x10800, {c = 0x1, d = 0x1}, type = {t = 0x0, ref = 0x7fffffffd3d0}, {next = 0x65a6d0, 
    jnext = 0x65a6d0}, prev = 0x65a760, prev_tok = 0x7ffff78c97b8}
(gdb) n
2402	}
(gdb) n
copy_ctype (to_type=0x7fffffffd460, from=0x663b10, symtab=0x663af8) at tccpp.c:2336
2336	}
(gdb) bt
#0  copy_ctype (to_type=0x7fffffffd460, from=0x663b10, symtab=0x663af8) at tccpp.c:2336
#1  0x000000000040bd34 in copy_extended_sym (symtab=0x663af8, from=0x663b10, to_tok=1073742960) at tccpp.c:2354
#2  0x000000000040b83b in copy_extended_tokensym (symtab=0x663af8, from=0x663d60, to=0x65bcc0) at tccpp.c:2203
#3  0x000000000040c3c6 in next_nomacro1 () at tccpp.c:2584
#4  0x000000000040ceef in next_nomacro_spc () at tccpp.c:2871
#5  0x000000000040cefa in next_nomacro () at tccpp.c:2878
#6  0x000000000040df2f in next () at tccpp.c:3315
#7  0x0000000000416c95 in block (bsym=0x0, csym=0x0, case_sym=0x0, def_sym=0x0, case_reg=0, is_expr=0) at tccgen.c:4636
#8  0x0000000000416b70 in block (bsym=0x0, csym=0x0, case_sym=0x0, def_sym=0x0, case_reg=0, is_expr=0) at tccgen.c:4602
#9  0x0000000000419501 in gen_function (sym=0x65a7f0) at tccgen.c:5717
#10 0x0000000000419e36 in decl0 (l=48, is_for_loop_init=0) at tccgen.c:5960
#11 0x000000000041a1bf in decl (l=48) at tccgen.c:6034
#12 0x0000000000403b8d in tcc_compile (s1=0x665340) at libtcc.c:795
#13 0x0000000000403dc1 in tcc_compile_string (s=0x665340, 
    str=0x638340 <second_code> "int fib_of_5() {\n    return fib(5);\n}\nvoid* get_fib_address() {\n    return &fib;\n}\n") at libtcc.c:849
#14 0x00000000004022f9 in main (argc=2, argv=0x7fffffffdd48) at 42-three-contexts-func-share.c:61

=====================
The anonymous symbol that holds the type for the function looks right. As the
stack trace reminds us, all of this was part of the ctype copy for the
identifier Sym in the "fib" TokenSym copy. We are finally beginning to unwind
the stack, returning to where we were back on line 982!
=====================

(gdb) n
copy_extended_sym (symtab=0x663af8, from=0x663b10, to_tok=1073742960) at tccpp.c:2355
2355		Sym * s = sym_push(to_tok, &to_type, from->r, from->c);
(gdb) p/x to_tok
$23 = 0x40000470
(gdb) n
2358		if (from->asm_label != NULL) {
(gdb) n
2365		if (from->next == NULL) return s;
(gdb) p from->next
$24 = (struct Sym *) 0x0
(gdb) n
2402	}
(gdb) p s
$25 = (Sym *) 0x65a688
(gdb) n
copy_extended_tokensym (symtab=0x663af8, from=0x663d60, to=0x65bcc0) at tccpp.c:2210
2210		if (from->sym_define == NULL || from->sym_define->d == NULL) {

=====================
The sym_push seemed to work fine---it is not null. Note the token id is 0x470.
We are nonw back in copy_extended_tokensym. Let's get to the end of the function
and then double-check that we've properly set up the "to" TokenSym.
=====================

(gdb) n
2211			to->sym_define = NULL;
(gdb) n
2307	}
(gdb) p/x *to
$26 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x65a688, tok = 0x40000470, len = 0x3, 
  str = {0x66}}
(gdb) p (char *)(to->str)
$27 = 0x65bcf0 "fib"

=====================
Token id looks right, string is correct, sym_identifier is NOT NULL. Let's keep
rolling and see what happens.
=====================

(gdb) info break
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000402244 in main at 42-three-contexts-func-share.c:61
	breakpoint already hit 1 time
2       breakpoint     keep y   0x000000000040b81a in copy_extended_tokensym at tccpp.c:2203
	breakpoint already hit 2 times
3       breakpoint     keep y   0x000000000040be8a in copy_extended_sym at tccpp.c:2392
	breakpoint already hit 1 time
(gdb) delete 1
(gdb) delete 2
(gdb) delete 3
(gdb) break tccgen.c:206
Breakpoint 4 at 0x40e7df: file tccgen.c, line 206.

=====================
I've cleared the breakpoints set so far and added a breakpoint for sym_find.
=====================

(gdb) c
Continuing.

Breakpoint 4, sym_find (v=1073742960) at tccgen.c:206
206	    int is_extended = v & SYM_EXTENDED;
(gdb) p/x v
$28 = 0x40000470

=====================
Got it!
=====================

(gdb) n
207	    v &= ~SYM_EXTENDED;
(gdb) n
208	    v -= TOK_IDENT;
(gdb) n
213	    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))
(gdb) p/x v
$29 = 0x370
(gdb) p/x tok_ident
$30 = 0x472
(gdb) n
221	    if (is_extended && (table_ident[v]->tok & SYM_EXTENDED)) {
(gdb) n
222	        TokenSym *ts = table_ident[v];
(gdb) n
225	        ts->tok &= ~SYM_EXTENDED;
(gdb) p *ts
$31 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x65a688, tok = 1073742960, len = 3, 
  str = "f"}
(gdb) p/x tok
$32 = 0x28
(gdb) p/x ts->tok
$33 = 0x40000470
(gdb) n
228	        if (tcc_state->symtab_sym_used_callback != NULL)
(gdb) p/x ts->tok
$34 = 0x470
(gdb) n
230	            tcc_state->symtab_sym_used_callback(ts->str, ts->len,
(gdb) n
231	                tcc_state->symtab_callback_data);
(gdb) n
230	            tcc_state->symtab_sym_used_callback(ts->str, ts->len,
(gdb) n
234	    return table_ident[v]->sym_identifier;
(gdb) p/x *(table_ident[v]->sym_identifier)
$35 = {v = 0x470, asm_label = 0x0, r = 0x230, {c = 0x0, d = 0x0}, type = {t = 0x86, ref = 0x65a718}, {next = 0x0, jnext = 0x0}, 
  prev = 0x65a6d0, prev_tok = 0x0}
(gdb) p table_ident[v]->sym_identifier
$36 = (struct Sym *) 0x65a688

=====================
Everything looks good here. We cleared the extended token flag for this local
TokenSym having called the callback. We are about to return a Sym pointer that
is not null.
=====================

(gdb) n
235	}
(gdb) n
unary () at tccgen.c:3892
3892	        if (!s) {
(gdb) p s
$37 = (Sym *) 0x65a688
(gdb) n
3902	        if ((s->type.t & (VT_STATIC | VT_INLINE | VT_BTYPE)) ==
(gdb) n
3913	            r = s->r;

=====================
OK... so everything looks fine. This whole lookup is part of the first use of
"fib" in the second code, namely the "return fib(5)". So, let's keep running and
see what happens as we trip the sym_find function.
=====================

(gdb) c
Continuing.

Breakpoint 4, sym_find (v=1138) at tccgen.c:206
206	    int is_extended = v & SYM_EXTENDED;
(gdb) p/x v
$38 = 0x472
(gdb) p *(table_ident[0x372])
$48 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x65a718, tok = 1138, len = 15, str = "g"}
(gdb) p (char*) (table_ident[0x372]->str)
$49 = 0x65bfc0 "get_fib_address"

=====================
OK, looks right to me. We shouldn't find a symbol for this since we're defining
it. Move on.
=====================

(gdb) c
Continuing.

Breakpoint 4, sym_find (v=263) at tccgen.c:206
206	    int is_extended = v & SYM_EXTENDED;
(gdb) p/x 263
$50 = 0x107
(gdb) p *(table_ident[0x7])
$53 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x0, tok = 263, len = 6, str = "r"}
(gdb) p (char*) (table_ident[0x7]->str)
$52 = 0x663a60 "return"

=====================
Yep, the first non-symbolic token in get_fib_address is "return". Keep going.
=====================

(gdb) c
Continuing.

Breakpoint 4, sym_find (v=1136) at tccgen.c:206
206	    int is_extended = v & SYM_EXTENDED;
(gdb) p *(table_ident[1036])
Cannot access memory at address 0x0
(gdb) p/x v
$43 = 0x470
(gdb) p *(table_ident[470])
$44 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x0, tok = 726, len = 5, str = "s"}
(gdb) p *(table_ident[370])
$45 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x0, tok = 626, len = 3, str = "s"}
(gdb) p *(table_ident[0x370])
$46 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x0, tok = 1136, len = 3, str = "f"}
(gdb) p (char*) (table_ident[0x370]->str)
$47 = 0x65bcf0 "fib"

=====================
This is definitely the correct number, but certainly the wrong sym_identifier!
(I also realized that I was referring to the wrong symbols before. I made a
couple of retroactive corrections, hence the out-of-order $return_variables
above.)

WHAT HAPPENED?

To find out what happened, I will need to place a watch on the sym_identifier
field of the TokenSym, after restarting the debugger. That looked like this:

=====================
(gdb) break 42-three-contexts-func-share.c:61
Breakpoint 1 at 0x402244: file 42-three-contexts-func-share.c, line 61.
(gdb) run
Starting program: /home/dcmertens/projects/Perl/tinycc/tests/exsymtab/42-three-contexts-func-share.dbg lib_path=../..
ok 1 - Code string with definition of fib function compiled and relocated fine
ok 2 - Found fib
ok 3 - Calling fib from first compiler context works
ok 4 - First code string compiled and relocated fine
ok 5 - foo

Breakpoint 1, main (argc=2, argv=0x7fffffffdd48) at 42-three-contexts-func-share.c:61
61		setup_and_compile_second_state(s2, second_code);
(gdb) break tccpp.c:2203
Breakpoint 2 at 0x40b81a: file tccpp.c, line 2203.
(gdb) c
Continuing.

Breakpoint 2, copy_extended_tokensym (symtab=0x663af8, from=0x663d60, to=0x65bcc0) at tccpp.c:2203
2203		to->sym_identifier = copy_extended_sym(symtab, from->sym_identifier, to->tok);
(gdb) delete 1
(gdb) delete 2
(gdb) n
2210		if (from->sym_define == NULL || from->sym_define->d == NULL) {
(gdb) p *to
$1 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x65a688, tok = 1073742960, len = 3, 
  str = "f"}
(gdb) watch to->sym_identifier
Hardware watchpoint 3: to->sym_identifier
(gdb) c
Continuing.

Watchpoint 3 deleted because the program has left the block in
which its expression is valid.
0x000000000040c3c6 in next_nomacro1 () at tccpp.c:2584
2584					if (extended_ts) copy_extended_tokensym(containing_symtab, extended_ts, ts);
(gdb) p/x *table_ident[0x370]
$2 = {hash_next = 0x0, sym_define = 0x0, sym_label = 0x0, sym_struct = 0x0, sym_identifier = 0x65a688, tok = 0x40000470, len = 0x3, str = {
    0x66}}
(gdb) watch table_ident[0x370]->sym_identifier
Hardware watchpoint 4: table_ident[0x370]->sym_identifier
(gdb) c
Continuing.
Hardware watchpoint 4: table_ident[0x370]->sym_identifier

Old value = (struct Sym *) 0x65a688
New value = (struct Sym *) 0x0
sym_pop (ptop=0x648fa8 <local_stack>, b=0x65a7a8) at tccgen.c:315
315	        sym_free(s);

=====================
The first few are working on getting me close enough to set a useful watch
point. The last few lines are what matter, indicating that the sym_identifier
gets reset during sym_pop, which is called whenever the compiler exits a block.
Hmm...

A close examination of sym_push reveals that it will push symbols to the local
symbol stack IF THE LOCAL SYMBOL STACK IS NOT NULL. While I could copy the code
of sym_push into its own subfunction, I think it would be easier to just backup
the current value of local_stack and set it to null upon entering the extended
copy machinery, so that sym_push Just Works. This I can do in next_nomacro1!

HURRAY! HURRAY! AT LONG LAST, IT WORKS! HURRAY!

December 3, 2014
================

And, with no change, test 45 passes its test suite, too, though perhaps it
shouldn't. In particular, when the "fib" symbol is added to the second compiler
state, tcc issues an error ("defined twice"), but continues anyway.

Tests 42 and 45 are fairly similar. The first one emulates a pre-compiled
library together with a header file, only the latter of which is shared in the
sense of extended symbol tables. The second emulates two compilation states in
which the second one depends upon the first, and the first *defines* a function
used in the second.

Interestingly enough, if I *omit* the tcc_add_symbol call in test 45, IT WORKS!

I am going to leave the line commented out, and make a note to address this idea
later, when the rest of the test suite is up and running.

Now, though, when I run test 20, it dies with a segmentation fault. :-( Nothing
a git bisect couldn't find, though. Turns out the local stack on/off logic was
not quite right, so I made it simpler.

With a couple of tcc_add_symbol lines commented out, test 47 now passes, too.
The same is true for test 48.

AND NOW FOR SOMETHING INTERESTING. Test 49 passes WITHOUT MODIFICATION. That is,
even with the tcc_add_symbol lines, it does not throw any errors. The difference
between 49 and the previous two is that the tcc compiler states were deleted
immediately after the machine code was relocated, preserving only the machine
code and note the compiler state. In that case, the functions *do* need to be
added, or I get an "undefined symbol 'fib'" error message! Put differently, if I
keep the compiler states around, then tcc correctly "links" against previously
compiled blocks of code.

This, of course, suggests a different test, one in which I write two functions
with the same name in non-shared contexts. Which one gets the linkage?

With the tcc_add_symbol line commented out, test 50 passes. And as before, test
51 passes without any modifications because it deletes it tcc states early and
often.

And with correct test harness setup, test 70 passes, too! WOW!

December 4, 2014
================

I have decided that I will need to create my own lookup table for function
pointers (and other symbols) that can live on even after I have deleted a tcc
state. That is, I need some way to say "tcc_get_symbol" even after I've deleted
the tcc state. This led me to create tccexsymtab.c, into which I will migrate
the bulk of the code I've written. The first functionality I wrote into that
file was a compressed trie, which I will use to create the symbol lookup table.
I may also use it to create a default lookup system for extended symbol tables.

My first thought was, "How hard is it to look up the global symbols in a
compiled tcc state?" A little bit of digging around tccelf.c, where
tcc_get_symbol is defined, led to a bit of hacking and the realization that it
is *really* *easy*. The current state of progress is codified in dump_sym_names,
a function that currently resides in tccelf.c. This function is called by the
not-quite-test dump-elf-syms.c in this directory. It seems to be working very
well.

December 5, 2014
================

OK, now we get to it. I would like to write a function that uses the compressed
trie I just implemented to store all of the global symbol pointers found in a
state's Section. I think, however, that I shall first move all of the extended
symbol table code into tccexsymtab.c to keep my work as cleanly separated from
the main codebase as possible.

December 9, 2014
================

After many days of hacking, I have re-implemented the bulk of the code using the
trie for lookup. The result is a huge commit with lots of changes, including a
few that could have been applied as small point-fixes. Oh well. The tests now
pass, and the whole thing is easier to comprehend, I hope.

December 10, 2014
=================

I decided that calling tcc_copy_extended_symbols after relocation is a
pessimization. I revised things so that the TCCState has a pointer slot for the
current extended symbol table, and symbols are automatically added during the
relocation stage if the slot has an extended symbol table. Since the state has a
slot for the extended symbol table, I can simply store the extended symbol table
there during compilation, rather than requiring a contorted callback function.
Now, callbacks are used only for extended symbol table lookups. This leads to
two code simplificatons. First, I reduce the number of callback functions,
easing the burden on library authors. Second, all callback functions and data
are only focused on symbol lookup, which makes them less cluttered.

At this stage, all of the tests pass, though many emit warnings. I am now in a
position to rewrite the tests to delete the tcc states as early as possible,
which will let me really test how the system is working.


At some point, should I add a test that checks which function gets linked when I
have multiple functions compiled in previous states under the same name?


December 31, 2014
=================

Added a new test, #31. There appear to be issues with struct members that are
arrays: the token for such members is (or at least can be) less than tok_start.
Why? How?

Look at the struct declared in test 31. Rumaging around using gdb, I see that
the int member has a good token id. The next member has a hax token id of
0x10000193. The last three digits should be a number greater than (roughly) 470.
To understand what's going on, start with tccgen.c:2862. This sees "int data[1]"
and so the first step, parse_btype, sets btype->t to 0 (type int). The next
token is the field's name, "data", so we proceed to call type_decl. This sets
the value of "v" to the token id of the token for "data" (line 3423), before
looking at the post-type, bringing me to line 3319. Following the code, we get
to line 3363, which pushes an anonymous symbol containing the array element
type; the token id is SYM_FIELD, a case that is already handled. Finally (as far
as the token id is concerned), we push the symbol on line 2984 with the v OR'ed
with SYM_FIELD. Which leads to the question: is "data" a token that exists
before we begin?

Aha! It is! To see this, type this into the debugger:
  p (char*)(table_ident[0x93]->str)
We get "data". At 0x92 we have "text" and at 0x94 we have "bss". Earlier in the
table give perfectly normal looking words that have (apparently) already been
declared for this compiler context, including "string", "space", "word", and
"align". Ostensibly, the exact same words are also declared for all other
compiler contexts, so referring to these tokens is simply a matter of copying
the token id.

However, all is not well with the world. While I no longer have a segfault, I do
have an "error: function pointer expected" with test 31. This, of course, is
because I try to re-use the token "new_list" as a variable name and as a
function name. Changing the variable "new_list" to simply "list" fixes that.
Looking closer, I realized that the test function was broken and didn't return
anything! Fixing that leads to a test 31 that passes! Hurray!

January 1, 2015
===============

C::Blocks work has uncovered what appears to be another bug involving the issue
I just fixed: a subtraction of tok_start. Reproducing the problem with a simple
C test case is difficult at the moment, so I am going to rely on a C::Blocks
test tha core dumps to figure out what's going on.

January 2, 2015
===============

Running the C::Blocks test through valgrind gives an interesting issue. By using
valgrind with --track-origins=yes, I get an "Uninitialised value" warning that I
can trace back to TOK___LINE__. This macro is "defined" as a null macro in
tcc_new, and its handling is special cased in tccpp.c. The problem appears to be
with type.t value, ostensibly being uninitialized. Yet this value *is*
initialized during sym_push2 to the function's third argument, which in this
case is called during define_push. The third argument to sym_push2 is the second
argument to define_push, which is MACRO_OBJ, which is defined in tcc.h as a
numeric constant. There should be no undefinedness going on here.

At this point I might figure that the type.t value was changed after its
initialization, to some value that was not initialized, but I don't think so. I
don't think anything messes with this token. You don't define struct members
with the name __LINE__.

All of this leads to the question: why is __LINE__ even showing up? Why would it
end up as a token being processed in get_new_symtab_pointer?

And then it hits me: the *allocation* occurs when __LINE__ is defined, but that
allocation is for a block of Syms. The Sym that is giving trouble is not the
__LINE__ Sym, but some other Sym that was allocated in that block. In that case,
the moment of creation for the Sym is worthless. However, I could change the
allocation of Syms to be on-demand...

And now we are on to something! It appears that there is a symbol that is
referenced which was freed:
==23182== Invalid read of size 8
==23182==    at 0x7275177: get_new_symtab_pointer (tccexsymtab.c:364)
==23182==    by 0x72759D5: copy_extended_symtab (tccexsymtab.c:510)
==23182==    by 0x72543C0: tcc_compile (libtcc.c:811)
==23182==    by 0x72544A2: tcc_compile_string_ex (libtcc.c:836)
==23182==    by 0x7047A7D: execute_compiler (Blocks.xs:524)
==23182==    by 0x70481B4: my_keyword_plugin (Blocks.xs:704)
==23182==    by 0x44FE0D: Perl_yylex (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==23182==    by 0x462717: Perl_yyparse (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==23182==    by 0x43C50D: perl_parse (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==23182==    by 0x41BD58: main (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==23182==  Address 0x6f35460 is 16 bytes inside a block of size 72 free'd
==23182==    at 0x4C2BE10: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23182==    by 0x7252CCA: tcc_free (libtcc.c:210)
==23182==    by 0x725DA65: sym_free (tccgen.c:153)
==23182==    by 0x725DFE4: sym_pop (tccgen.c:318)
==23182==    by 0x72669A8: block (tccgen.c:4626)
==23182==    by 0x7269537: gen_function (tccgen.c:5720)
==23182==    by 0x7269F19: decl0 (tccgen.c:5963)
==23182==    by 0x726A2AF: decl (tccgen.c:6037)
==23182==    by 0x72542B9: tcc_compile (libtcc.c:794)
==23182==    by 0x72544A2: tcc_compile_string_ex (libtcc.c:836)
==23182==    by 0x7047A7D: execute_compiler (Blocks.xs:524)
==23182==    by 0x70481B4: my_keyword_plugin (Blocks.xs:704)

More sleuthing and adding some code led to this:

==26972== Invalid read of size 4
==26972==    at 0x72759AE: copy_extended_symtab (tccexsymtab.c:509)
==26972==    by 0x72543C0: tcc_compile (libtcc.c:811)
==26972==    by 0x72544A2: tcc_compile_string_ex (libtcc.c:836)
==26972==    by 0x7047A7D: execute_compiler (Blocks.xs:524)
==26972==    by 0x70481B4: my_keyword_plugin (Blocks.xs:704)
==26972==    by 0x44FE0D: Perl_yylex (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==26972==    by 0x462717: Perl_yyparse (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==26972==    by 0x43C50D: perl_parse (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==26972==    by 0x41BD58: main (in /home/dcmertens/perl5/perlbrew/perls/perl-5.20.1/bin/perl)
==26972==  Address 0x6f35450 is 0 bytes inside a block of size 72 free'd
==26972==    at 0x4C2BE10: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==26972==    by 0x7252CCA: tcc_free (libtcc.c:210)
==26972==    by 0x725DA65: sym_free (tccgen.c:153)
==26972==    by 0x725DFE4: sym_pop (tccgen.c:318)
==26972==    by 0x72669A8: block (tccgen.c:4626)
==26972==    by 0x7269537: gen_function (tccgen.c:5720)
==26972==    by 0x7269F19: decl0 (tccgen.c:5963)
==26972==    by 0x726A2AF: decl (tccgen.c:6037)
==26972==    by 0x72542B9: tcc_compile (libtcc.c:794)
==26972==    by 0x72544A2: tcc_compile_string_ex (libtcc.c:836)
==26972==    by 0x7047A7D: execute_compiler (Blocks.xs:524)
==26972==    by 0x70481B4: my_keyword_plugin (Blocks.xs:704)
==26972== 
token id is 8000000

I managed to trip the invalid read one level up the stack trace and print out
the token id, in hex. This token value is SYM_FIRST_ANOM and corresponds with
the first anonymous symbol. What odities are occurring with the first anonymous
symbol? To find out, run gdb with:

  LD_LIBRARY_PATH="/home/dcmertens/projects/Perl/temp-install/lib" \
    gdb --args perl -Mblib -Mlib=inc t/11-clex-series.t
  
  (gdb) break tcc_new
  (gdb) run
  ... breaks ...
  (gdb) clear
  (gdb) watch anon_sym
  (gdb) c
  ...

With the first change, set a watch on that symbol's type.ref:
  Hardware watchpoint 2: anon_sym
  
  Old value = 134217728
  New value = 134217729
  0x00007ffff6384345 in get_sym_ref (type=0x7fffffffc770, sec=0xba4bb0, offset=0, size=7) at tccgen.c:417
  warning: Source file is more recent than executable.
  417	    v = anon_sym++;
  (gdb) n
  418	    sym = global_identifier_push(v, type->t | VT_STATIC, 0);
  (gdb) n
  419	    sym->type.ref = type->ref;

Now that I have the type.ref of interest, I can see how the type.ref changes by
creating another watchpoint:

  (gdb) p &(sym->type.ref)
  $1 = (struct Sym **) 0xba6508
  (gdb) watch *$1

That address triggers multiple times under various functions including
__strcpy_sse2_unaligned, __memmove_ssse3_back, and __memmove_ssse3_back. These
seem to refer to relocations. Examining the stack trace reveals that this branch
of unary() is the one for string constants, i.e. "Hello!" in the test script.
This value is "put" as an extern sym in get_sym_ref, so clearly this sym is
tracking the pointer location of the string constant. Probably the most
important marker for this is what is set in get_sym_ref for the r field:
  sym->r = VT_CONST | VT_SYM
This pairing shows up frequently in tccgen.c, but I suspect that if it is there,
then the next field should either be ignored, or simply copied verbatim. In all
likelihood, this refers to a Sym that I shouldn't be copying in the first place.
After all, why am I copying a Sym that refers to a string constant that I'll
never be able to invoke in later code blocks?

The more I think about it and read around, the more I think I should ignore any
symbol with an r flag of VT_SYM. Thus, in the "symbol stack" section of
copy_extended_symtab, I should not count them in N_Syms, and I should not
copy them later. Further investigations reveal, however, that a number of Syms
have VT_SYM, but only the anonymous symbol causing trouble has VT_SYM in the r
field and VT_STATIC in type.t. So, I think I can safely skip all such Syms in
the copy process.

But no! If I do that, I get this error:
  function pointer expected

Bother. So, I simply alter the copy behavior of the type.ref. If the Sym has all
the outward markings of something whose next field would be modified during the
actual compilation and/or relocation stage, then I copy the next value directly.
Otherwise, I make a new Sym and copy the contents. In all likelihood, this will
require modification for EXTERN Syms, too. Only tests will tell.



Note to self: only mark tokens as extended if they have a non-null identifier Sym.

Note: might be able to streamline external linkage of functions. See test 45.
